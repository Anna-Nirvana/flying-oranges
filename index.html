<head>
  <style>
    body {
      margin: 0;
    }
  </style>

  <script src="//unpkg.com/three"></script>
  <script src="//unpkg.com/three/examples/js/controls/TrackballControls.js"></script>
  <script src="//unpkg.com/three-globe"></script>
  <!--<script src="../../dist/three-globe.js"></script>-->
</head>

<body>
  <div id="globeViz"></div>

  <script>

  // Loading
    const textureLoader = new THREE.TextureLoader()
    const normalTexture = textureLoader.load('./static/textures/EarthSpec.png')

  // // Debug -- add dat.gui to script sources
  // const gui = new dat.GUI()

  //test globe material
  const material = new THREE.MeshStandardMaterial()
    material.metalness = 0.7
    material.roughness = 0.9
    material.flatShading = true;
    // material.vertexColors = true;
    // material.normalMap = normalTexture;
    material.color = new THREE.Color(0x2D80F1)


  const colorByProduct = {
    Almonds: '#B83C06',
    Wine: '#B83C06'
  }

  const latLong = {

    California: {
      lat: 36.7783,
      long: -106.3468,
    },
    
    Canada: {
      lat: 56.1304,
      long: -119.4179,
    }

  }

  const Sample = {

      Almonds: {
        Canada: 199209810,
        // "India":766845343,
        // "Japan": 269625440,
        // "UAE": 256403587,
        // "S. Korea": 170631823,
        },

      Wine: {
        Canada: 199209810,
        // "India":766845343,
        // "Japan": 269625440,
        // "UAE": 256403587,
        // "S. Korea": 170631823,
        },
      
      //add more produce!

  }

    // Placeholder data
    // const N = 20;

    // const arcsData = [...Array(N).keys()].map(() => ({
    //   startLat: (Math.random() - 0.5) * 180,
    //   startLng: (Math.random() - 0.5) * 360,
    //   endLat: (Math.random() - 0.5) * 180,
    //   endLng: (Math.random() - 0.5) * 360,
    //   color: ['#2274A5', '#B49082', '#98473E', '#A37C40'][Math.round(Math.random() * 3)]
    // }));

    let arcsData = [];

    for (const [product, countriesByProduct] of Object.entries(Sample))
    {
      for (const [country, value] of Object.entries(countriesByProduct))
      {
        arcsData.push({
          startLat: latLong.California.lat,
          startLng: latLong.California.long,
          endLat: latLong[country].lat,
          endLng: latLong[country].long,
          color: colorByProduct[product]
        });
      }
    }
    console.log(arcsData);

    // [Sample.Almonds.keys()].map((country) => ({
    //   startLat: latLong.California.lat,
    //   startLong: latLong.California.long,
    //   endLat: latLong[country].lat,
    //   endLong: latLong[country].long,
    //   color: colorByProduct.Almonds
    // }))

    const sphere = new ThreeGlobe()
      .globeImageUrl('//unpkg.com/three-globe/example/img/earth-night.jpg')
      // .bumpImageUrl('./static/textures/EarthNormal.png')
      // .globeMaterial(material)
      .arcsData(arcsData)
      .arcColor('color')
      .arcDashLength(0.4)
      .arcDashGap(4)
      // .arcStroke()
      .arcDashInitialGap(() => Math.random() * 5)
      .arcDashAnimateTime(1000);

    // Setup renderer
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('globeViz').appendChild(renderer.domElement);

    // Setup scene
    const scene = new THREE.Scene();
    scene.add(sphere);
    scene.add(new THREE.AmbientLight(0xbbbbbb));
    scene.add(new THREE.DirectionalLight(0xffffff, 0.6));

    // Setup camera
    const camera = new THREE.PerspectiveCamera();
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    camera.position.z = 500;

    // Add camera controls
    const tbControls = new THREE.TrackballControls(camera, renderer.domElement);
    tbControls.minDistance = 101;
    tbControls.rotateSpeed = 5;
    tbControls.zoomSpeed = 0.8;

    // Kick-off renderer
    (function animate() { // IIFE
      // Frame cycle
      tbControls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    })();

    /**
 * Animate
 */

//add interactivity based on mouse latLong
document.addEventListener('mousemove', onDocumentMouseMove)

let mouseX = 0
let mouseY = 0

let targetX = 0
let targetY = 0

const windowX = window.innerWidth / 2;
const windowY = window.innerHeight / 2;

function onDocumentMouseMove(event) {
    mouseX = (event.clientX - windowX) //clientX means X latLong of mouse
    mouseY = (event.clientY - windowY)
}
function updateSphere(event) {
    sphere.position.y = window.scrollY * 0.001
    }

window.addEventListener('scroll', updateSphere);


const clock = new THREE.Clock()

const tick = () =>
{

    targetX = mouseX * 0.001
    targetY = mouseY * 0.001

    const elapsedTime = clock.getElapsedTime()

    // Update objects
    sphere.rotation.y = .5 * elapsedTime //general starting rotation

    sphere.rotation.y += .5 * (targetX - sphere.rotation.y)
    sphere.rotation.x += .05 * (targetY - sphere.rotation.x)
    sphere.position.z += -.05 * (targetY - sphere.rotation.x)

    // Update Orbital Controls
    // controls.update()

    // Render
    renderer.render(scene, camera)

    // Call tick again on the next frame
    window.requestAnimationFrame(tick)
}

tick()

  </script>
</body>
